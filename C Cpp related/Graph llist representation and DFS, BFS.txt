#include <stdio.h>
#include <stdlib.h>
// ******** queue structure ********
struct queue {
    int data[20];
    int front,rear;
}q1;
// ******** graph structure(using linked list) ********
struct node {
    int vertex;
    struct node *next;
} *v[10]; // [[[WE ARE CREATING ARRAY OF VERTEX OR NODES THEREFORE WE HAVE GLOBALLY DELCARED ARRAY OF NODES]]]

// ******** queue Utility functions ********
void add(int n){
    q1.rear++;
    q1.data[q1.rear]= n;
}
int del(){
    q1.front++;
    return q1.data[q1.front];
}
void initq(){
    q1.front = q1.rear = -1;
}
int emptyq(){
    return(q1.rear == q1.front);
}

// ******** Graph Utility functions(Adjacency Matrix) ********
void create(int adj[10][10], int n){
    int i,j;
    for(i=0;i<n;i++){
        for(j=0;j<n;j++){
            adj[i][j] = 0;
            printf("Entre edge from %d to %d (1 : Edge, 0 : No Edge) \n",i+1,j+1);
            scanf("%d",&adj[i][j]);
        }
    }
}
void display(int adj[10][10], int n){
    int i,j;
    printf("The adjacency matrix is \n");
    for(i=0;i<n;i++){
        for(j=0;j<n;j++){
            printf("%d ",adj[i][j]);
        }
        printf("\n");
    }
}
// ******** Graph Utility functions(Linked list) ********
void create1 (int m[10][10], int n){
    int i,j;
    struct node *temp,*newnode;
    for (i = 0; i < n; i++) {
        v[i] = NULL;
        for (j = 0; j < n; j++) {
            if(m[i][j] == 1){
                newnode = (struct node*)malloc(sizeof(struct node));
                newnode->next = NULL;
                newnode->vertex = j+1;
                if(v[i] == NULL){
                    v[i] = temp = newnode;
                }else{
                    temp->next = newnode;
                    temp = temp->next;
                }
            }
        }
    }
}
void displaylist(int n){
    struct node *temp;
    int i;
    for(i=0;i<n;i++){
        printf("\n v%d | ",i+1);
        temp = v[i];
        while(temp){
            printf("v%d -> ",temp->vertex);
            temp=temp->next;
        }
        printf("Null\n");
    }
}

// ******** Graph Traversal Algoritms ********
void bfs(int m[10][10], int n){
    int i,j,v,w;
    int visited[20];
    initq();
    for(i=0;i<n;i++)
        visited[i]=0;
    printf("\n The BFS Traversal is : ");
    v=0;
    visited[v] = 1;
    add(v);
    while(!emptyq()){
        v = del();
        printf("v%d ",v+1);
        for(w=0;w<n;w++){
            if(m[v][w] = 1 && visited[w] == 0){
                add(w);
                visited[w] = 1;
            }
            
        }
    }
}
void dfs(int m[10][10], int n, int i, int visited[]) {
    int k;
    visited[i] = 1;
    printf("%d ",i+1);
    for(k=0;k<n;k++){
        if(m[i][k] == 1 && visited[k] == 0){
            dfs(m,n,k,visited);
        }
    }
}
int main()
{
    int m[10][10];
    int n;
    printf("Entre no. of vertices \n");
    scanf("%d",&n);
    create(m,n);
    display(m,n);
    create1(m,n);
    displaylist(n);
    bfs(m,n);
    int visited[20];
    int i;
    for(i=0;i<20;i++)
        visited[i]=0;
    printf("\n");
     printf("\n The DFS Traversal is : ");
    dfs(m,n,0,visited);
    
    return 0;
}
v