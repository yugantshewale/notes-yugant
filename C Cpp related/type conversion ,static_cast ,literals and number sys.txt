C++ will allow us to convert values of one fundamental type to another fundamental type. The process of converting a value from 
one type to another type is called type conversion.When the compiler does type conversion on our behalf without us explicitly 
asking, we call this implicit type conversion. 

Explicit type conversion via the static_cast operator
Explicit type conversion allow us (the programmer) to explicitly tell the compiler to convert a value from one type to another 
type, and that we take full responsibility for the result of that conversion. If such a conversion results in the loss of value, 
the compiler will not warn us.
To perform an explicit type conversion, in most cases we’ll use the static_cast operator. The syntax for the static cast looks a 
little funny:
static_cast<new_type>(expression)
example:
#include <iostream>

void print(int x)
{
	std::cout << x << '\n';
}

int main()
{
	print( static_cast<int>(5.5) ); // explicitly convert double value 5.5 to an int

	return 0;
}
_________________________________________________________________________________________________________________________________
Literals
Literals are values that are inserted directly into the code. For example:

return 5;                     // 5 is an integer literal
bool myNameIsAlex { true };   // true is a boolean literal
double d { 3.4 };             // 3.4 is a double literal
std::cout << "Hello, world!"; // "Hello, world!" is a C-style string literal

The type of a literal
Just like objects have a type, all literals have a type. The type of a literal is deduced from the literal’s value. For example, a 
literal that is a whole number (e.g. 5) is deduced to be of type int.
By default:
___________________________________________________________________________________________________________
Literal value	     |  Examples       | Default literal type |	Note                                      |
_____________________|_________________|______________________|___________________________________________| 
integer value	     | 5, 0, -3	       | int	  	      |                                           |
boolean value	     | true, false     | bool		      |                                           |
floating point value | 1.2, 0.0, 3.4   | double (not float!)  |                                           |	
character	     | ‘a’, ‘\n’       | char	    	      |                                           |
C-style string	     | “Hello, world!” | const char[14]	      | see C-style string literals section below |
_____________________|_________________|______________________|___________________________________________|

Literal suffixes
If the default type of a literal is not as desired, you can change the type of a literal by adding a suffix. 
Here are some of the more common suffixes:
_____________________________________________________________________________________________________
Data type      | Suffix					| Meaning				    |
_______________|________________________________________|___________________________________________|
integral       | u or U					| unsigned int       			    |
integral       | l or L					| long           			    |
integral       | ul, uL, Ul, UL, lu, lU, Lu, LU		| unsigned long     			    |
integral       | ll or LL			 	| long long			    	    |
integral       | ull, uLL, Ull, ULL, llu, llU, LLu, LLU	| unsigned long long			    |
integral       | z or Z	    				| The signed version of std::size_t (C++23) |
integral       | uz, uZ, Uz, UZ, zu, zU, Zu, ZU		| std::size_t (C++23)			    |
floating point | f or F					| float              			    |
floating point | l or L					| long double       			    |
string	       | s					| std::string      			    |
string	       | sv					| std::string_view			    |
_______________|________________________________________|___________________________________________|
In most cases, suffixes aren’t needed (except for f).
Excepting the f suffix, suffixes are most often used in cases where type deduction is involved

Suffix casing
Most of the suffixes are not case sensitive. The exceptions are:
s and sv must be lower case.
Two consecutive l or L characters must have the same casing.
example:
#include <iostream>

int main()
{
    std::cout << 5 << '\n';  // 5 (no suffix) is type int (by default)
    std::cout << 5L << '\n'; // 5L is type long
    std::cout << 5u << '\n'; // 5u is type unsigned int

    return 0;
}

Floating point literals
By default, floating point literals have a type of double. 
To make them float literals instead, the f (or F) suffix should be used:
float f { 4.1f }; // use 'f' suffix so the literal is a float and matches variable type of float
double d { 4.1 }; // change variable to type double so it matches the literal type double

Scientific notation for floating point literals
In scientific notation, we add an e to represent the exponent:
double avogadro { 6.02e23 }; // 6.02 x 10^23 is a double literal in scientific notation
double protonCharge { 1.6e-19 }; // charge on a proton is 1.6 x 10^-19

Magic numbers
A magic number is a literal (usually a number) that either has an unclear meaning or may need to be changed later.
_________________________________________________________________________________________________________________________________
Numeral systems (decimal, binary, hexadecimal, and octal)

int x { 12 }; // 12 is assumed to be a decimal number

Octal and hexadecimal literals
Octal is base 8 -- that is, the only digits available are: 0, 1, 2, 3, 4, 5, 6, and 7. In Octal,
we count like this: 0, 1, 2, 3, 4, 5, 6, 7, 10, 11, 12, … (note: no 8 and 9, so we skip from 7 to 10).

To use an octal literal, prefix your literal with a 0 (zero):
#include <iostream>

int main()
{
    int x{ 012 }; // 0 before the number means this is octal
    std::cout << x << '\n';
    return 0;
}

This program prints:
10
10 in octadeciaml is 12

Hexadecimal 
Hexadecimal is base 16. In hexadecimal, we count like this: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, 10, 11, 12, …
To use a hexadecimal literal, prefix your literal with 0x:

#include <iostream>

int main()
{
    int x{ 0xF }; // 0x before the number means this is hexadecimal
    std::cout << x << '\n';
    return 0;
}

This program prints:
15

You can also use a 0X prefix, but 0x is conventional because its easier to read.

Binary literals
Prior to C++14, there is no support for binary literals. However, hexadecimal literals provide us with a useful workaround 
(that you may still see in existing code bases):

#include <iostream>
int main()
{
    int bin{};    // assume 16-bit ints
    bin = 0x0001; // assign binary 0000 0000 0000 0001 to the variable
    bin = 0x0002; // assign binary 0000 0000 0000 0010 to the variable
    bin = 0x0004; // assign binary 0000 0000 0000 0100 to the variable
    bin = 0x0008; // assign binary 0000 0000 0000 1000 to the variable
    bin = 0x0010; // assign binary 0000 0000 0001 0000 to the variable
    bin = 0x0020; // assign binary 0000 0000 0010 0000 to the variable
    bin = 0x0040; // assign binary 0000 0000 0100 0000 to the variable
    bin = 0x0080; // assign binary 0000 0000 1000 0000 to the variable
    bin = 0x00FF; // assign binary 0000 0000 1111 1111 to the variable
    bin = 0x00B3; // assign binary 0000 0000 1011 0011 to the variable
    bin = 0xF770; // assign binary 1111 0111 0111 0000 to the variable

    return 0;
}

In C++14 onward, we can use binary literals by using the 0b prefix:

#include <iostream>
int main()
{
    int bin{};        // assume 16-bit ints
    bin = 0b1;        // assign binary 0000 0000 0000 0001 to the variable
    bin = 0b11;       // assign binary 0000 0000 0000 0011 to the variable
    bin = 0b1010;     // assign binary 0000 0000 0000 1010 to the variable
    bin = 0b11110000; // assign binary 0000 0000 1111 0000 to the variable

    return 0;
}

Digit separators
Because long literals can be hard to read, C++14 also adds the ability to use a quotation mark (‘) as a digit separator.

#include <iostream>
int main()
{
    int bin { 0b1011'0010 };  // assign binary 1011 0010 to the variable
    long value { 2'132'673'462 }; // much easier to read than 2132673462

    return 0;
}

Also note that the separator can not occur before the first digit of the value:
int bin { 0b'1011'0010 };  // error: ' used before first digit of value
These are for visual purpose only

Outputting values in decimal, octal, or hexadecimal
By default, C++ outputs values in decimal. However, you can change the output format via use of the std::dec, std::oct, and 
std::hex I/O manipulators:

#include <iostream>
int main()
{
    int x { 12 };
    std::cout << x << '\n'; // decimal (by default)
    std::cout << std::hex << x << '\n'; // hexadecimal
    std::cout << x << '\n'; // now hexadecimal
    std::cout << std::oct << x << '\n'; // octal
    std::cout << std::dec << x << '\n'; // return to decimal
    std::cout << x << '\n'; // decimal

    return 0;
}

Outputting values in binary
Outputting values in binary is a little harder, as std::cout doesn’t come with this capability built-in. Fortunately, the 
C++ standard library includes a type called std::bitset that will do this for us (in the <bitset> header).
To use std::bitset, we can define a std::bitset variable and tell std::bitset how many bits we want to store. 
The number of bits must be a compile-time constant. std::bitset can be initialized with an integral value (in any format, 
including decimal, octal, hex, or binary).

#include <bitset> // for std::bitset
#include <iostream>
int main()
{
	// std::bitset<8> means we want to store 8 bits
	std::bitset<8> bin1{ 0b1100'0101 }; // binary literal for binary 1100 0101
	std::bitset<8> bin2{ 0xC5 }; // hexadecimal literal for binary 1100 0101

	std::cout << bin1 << '\n' << bin2 << '\n';
	std::cout << std::bitset<4>{ 0b1010 } << '\n'; // create a temporary std::bitset and print it

	return 0;
}

This prints:
11000101
11000101
1010

In the above code, this line:
std::cout << std::bitset<4>{ 0b1010 } << '\n'; // create a temporary std::bitset and print it
creates a temporary (unnamed) std::bitset object with 4 bits, initializes it with binary literal 0b1010, prints the value 
in binary, and then discards the temporary object.

Outputting values in binary using the Format / Print Library Advanced
In C++20 and C++23, we have better options for printing binary via the new Format Library (C++20) and Print Library (C++23):

#include <format> // C++20
#include <iostream>
#include <print> // C++23
int main()
{
    std::cout << std::format("{:b}\n", 0b1010);  // C++20, {:b} formats the argument as binary digits
    std::cout << std::format("{:#b}\n", 0b1010); // C++20, {:#b} formats the argument as 0b-prefixed binary digits

    std::println("{:b} {:#b}", 0b1010, 0b1010);  // C++23, format/print two arguments (same as above) and a newline

    return 0;
}

This prints:
1010
0b1010
1010 0b1010