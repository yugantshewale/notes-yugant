Computers have random access memory (RAM) that is available for programs to use.
When a variable is defined, a piece of that memory is set aside for that variable.

The smallest unit of memory is a binary digit (also called a bit), which can hold a value of 0 or 1. 
You can think of a bit as being like a traditional light switch -- either the light is off (0), or it is on (1). 
There is no in-between. If you were to look at a random segment of memory, all you would see is …011010100101010… or some 
combination thereof.

Memory is organized into sequential units called memory addresses (or addresses for short). 
Similar to how a street address can be used to find a given house on a street, the memory address allows us to find and access 
the contents of memory at a particular location.

In modern computer architectures, each bit does not get its own unique memory address. 
This is because the number of memory addresses is limited, and the need to access data bit-by-bit is rare. 
Instead, each memory address holds 1 byte of data. A byte is a group of bits that are operated on as a unit.
 
The modern standard is that a byte is comprised of 8 sequential bits.

Fundamental data types
C++ comes with built-in support for many different data types. 
These are called fundamental data types, but are often informally called basic types, primitive types, or built-in types.
Here is a list of the fundamental data types, some of which you have already seen:
_________________________________________________________________________________________________
Types	               | Category	       | Meaning	                     | Example  |
_______________________|_______________________|_____________________________________|__________|
float	               |		       |			             |		|
double	               | Floating Point	       | a number with a fractional          | 3.14159	|
long double            |                       |				     |		|
_______________________|_______________________|_____________________________________|__________|	           
bool	               | Integral (Boolean)    | true or false			     | true	|
_______________________|_______________________|_____________________________________|__________|
char	               |		       |                                     |		|
wchar_t	               | 		       |				     |		|
char8_t (C++20)        | Integral (Character)  | a single character of text          | ‘c’	|
char16_t (C++11)       |		       |				     |		|
char32_t (C++11)       |		       |				     |		|
_______________________|_______________________|_____________________________________|__________|
short int              |		       |				     |		|
int                    |Integral (Integer)     | positive and negative whole numbers | 64	|
long int               |	               | including 0			     |		|
long long int (C++11)  |		       |				     |		|
_______________________|_______________________|_____________________________________|__________|
std::nullptr_t (C++11) | Null Pointer          | a null pointer			     | nullptr	|
_______________________|_______________________|_____________________________________|__________|
void                   | Void	               | no type                             | n/a	|
_______________________|_______________________|_____________________________________|__________|

The term “integral” means “like an integer”. Most often, “integral” is used as part of the term “integral type”, 
which includes the broader set of types that are stored in memory as integers, even though their behaviors might vary

An incomplete type is a type that has been declared but not yet defined.  The compiler knows about the existence of such types, 
but does not have enough information to determine how much memory to allocate for objects of that type. void is intentionally 
incomplete since it represents the lack of a type, and thus cannot be defined.
Void is our first example of an incomplete type. 
eg : void value; // won't work, variables can't be defined with incomplete type void

Void is typically used in several different contexts.
	Functions that do not return a value
	Deprecated: Functions that do not take parameters
		eg : int getValue(void) // void here means no parameters or you can also do : int getValue()
		     {
    		     	int x{};
      			std::cin >> x;
 			return x;
		     }

A byte is 8 bits.
Memory is byte addressable (we can access every byte of memory independently).
Floating point support is IEEE-754 compliant.
We are on a 32-bit or 64-bit architecture.

_________________________________________________________________________
Category       | Type	        | Minimum Size	   | Typical Size    	|
_______________|________________|__________________|____________________|
Boolean	       | bool	 	| 1 byte	   | 1 byte		|
_______________|________________|__________________|____________________|
Character      | char		| 1 byte (exactly) | 1 byte		|
	       | wchar_t	| 1 byte	   | 2 or 4 bytes	|
	       | char8_t	| 1 byte	   | 1 byte		|
	       | char16_t	| 2 bytes	   | 2 bytes		|
	       | char32_t	| 4 bytes	   | 4 bytes		|
_______________|________________|__________________|____________________|
Integral       | short		| 2 bytes	   | 2 bytes		|
	       | int	        | 2 bytes	   | 4 bytes		|
	       | long	        | 4 bytes	   | 4 or 8 bytes	|
	       | long long	| 8 bytes          | 8 bytes		|
_______________|________________|__________________|____________________|
Floating point | float		| 4 bytes	   | 4 bytes		|
	       | double    	| 8 bytes	   | 8 bytes		|
	       | long double	| 8 bytes	   | 8, 12, or 16 bytes |
_______________|________________|__________________|____________________|
Pointer	       | std::nullptr_t	| 4 bytes	   | 4 or 8 bytes	|
_______________|________________|__________________|____________________|

Fixed-width integers and size_t
If you assume an int is 32-bits because that’s most likely, then your program will probably misbehave on architectures where int
is actually 16-bits (since you will probably be storing values that require 32-bits of storage in a variable with only 16-bits 
of storage, which will cause overflow or undefined behavior).
    To address the above issues, C++11 provides an alternate set of integer types that are guaranteed to be the same size on 
any architecture. Because the size of these integers is fixed, they are called fixed-width integers.

The fixed-width integers are defined (in the <cstdint>\ header) as follows:
__________________________________________________________________________________________________________________
Name	      | Fixed Size	| Fixed Range			  | Notes					  |	
______________|_________________|_________________________________|_______________________________________________|           
std::int8_t   | 1 byte signed	| -128 to 127			  | Treated like a signed char on many systems.   |
	      |			|				  | See note below.				  |
______________|_________________|_________________________________|_______________________________________________|
std::uint8_t  | 1 byte unsigned	| 0 to 255			  | Treated like an unsigned char on many systems.| 
	      |			|				  | See note below.				  |
______________|_________________|_________________________________|_______________________________________________|
std::int16_t  | 2 byte signed	| -32,768 to 32,767		  |						  |
______________|_________________|_________________________________|_______________________________________________|
std::uint16_t | 2 byte unsigned	| 0 to 65,535			  |						  |
______________|_________________|_________________________________|_______________________________________________|
std::int32_t  |	4 byte signed	| -2,147,483,648 to 2,147,483,647 |						  |
______________|_________________|_________________________________|_______________________________________________|
std::uint32_t |	4 byte unsigned	| 0 to 4,294,967,295		  |						  |
______________|_________________|_________________________________|_______________________________________________|
std::int64_t  |	8 byte signed	| -9,223,372,036,854,775,808 to   |						  |
	      |			| 9,223,372,036,854,775,807	  |						  |
______________|_________________|_________________________________|_______________________________________________|
std::uint64_t |	8 byte unsigned	| 0 to 18,446,744,073,709,551,615 |						  |
______________|_________________|_________________________________|_______________________________________________|

Here's an example :
	#include <cstdint> // for fixed-width integers
	#include <iostream>

	int main()
	{
	    std::int32_t x { 32767 }; // x is always a 32-bit integer
	    x = x + 1;                // so 32768 will always fit
	    std::cout << x << '\n';

	    return 0;
	}

Use a fixed-width integer type when you need an integral type that has a guaranteed range.

Warning: std::int8_t and std::uint8_t typically behave like chars

Fast and least integral types Optional
To help address the above downsides, C++ also defines two alternative sets of integers that are guaranteed to exist.
The fast types (std::int_fast#_t and std::uint_fast#_t) provide the fastest signed/unsigned integer type with a width
of at least # bits (where # = 8, 16, 32, or 64). For example, std::int_fast32_t will give you the fastest signed integer
type that’s at least 32-bits. By fastest, we mean the integral type that can be processed most quickly by the CPU.
    The least types (std::int_least#_t and std::uint_least#_t) provide the smallest signed/unsigned integer type with a width of 
at least # bits (where # = 8, 16, 32, or 64). For example, std::uint_least32_t will give you the smallest unsigned integer type 
that’s at least 32-bits.

Here’s an example from the author’s Visual Studio (32-bit console application):

#include <cstdint> // for fast and least types
#include <iostream>

int main()
{
	std::cout << "least 8:  " << sizeof(std::int_least8_t)  * 8 << " bits\n";
	std::cout << "least 16: " << sizeof(std::int_least16_t) * 8 << " bits\n";
	std::cout << "least 32: " << sizeof(std::int_least32_t) * 8 << " bits\n";
	std::cout << '\n';
	std::cout << "fast 8:  "  << sizeof(std::int_fast8_t)   * 8 << " bits\n";
	std::cout << "fast 16: "  << sizeof(std::int_fast16_t)  * 8 << " bits\n";
	std::cout << "fast 32: "  << sizeof(std::int_fast32_t)  * 8 << " bits\n";

	return 0;
}

This produced the result:

least 8:  8 bits
least 16: 16 bits
least 32: 32 bits

You can see that std::int_least16_t is 16-bits, whereas std::int_fast16_t is actually 32-bits.
This is because on the author’s machine, 32-bit integers are faster to process than 16-bit integers.
As another example, let’s assume we’re on an architecture that has only 16-bit and 64-bit integral types. 
std::int32_t would not exist, whereas std::least_int32_t (and std::fast_int32_t) would be 64 bits.

Avoid the fast and least integral types because they may exhibit different behaviors on architectures where they resolve
to different sizes.

