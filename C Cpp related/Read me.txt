So the way I made main1 was by first changing directory like we do in linux using the terminal here we do using
command prompt.
So the way I think this work is we are splitting one code in two files of cpp called main.cpp and add.cpp here if I 
compile add.cpp seperately it will give me error as I am missing main function in the code and main.cpp will not compile
since it hasn't defined the add function yet.
	But if these two files are linked through a linker(idk if it like obj file or 
cpp file for reference link - https://www.learncpp.com/cpp-tutorial/introduction-to-the-compiler-linker-and-libraries/)
and then compiled it will act as one propgram and for this reason we do it on cmd prompt we can also do it in sublime or
VS code but idk how remember they are part of one program just split in different file we need to compile then at same 
time so that they work together and to do that we do following steps.
__________________________________________________________________________________________
STEP 1 > cd "C:\Users\hp\Desktop\cp uploader\temp"............... Changing directory

STEP 2 > g++ main.cpp add.cpp -o main1 .............for context temp contained files called main.cpp and add.cpp
						    and notice after -o we name our object file or executable file
                                                    called main1.exe here both add.cpp and main.cpp are linked and
						    is going to act as one program.

STEP # > main1.exe ............... to execute the file
_______________________________________________________________________________________________
***********************************************************************************************
What Happens When You Compile add.cpp Alone?
If you run: >> g++ add.cpp -o add_program
You’ll get a linker error like: >> /usr/bin/ld: ... undefined reference to `main'
This is because
	The compiler treats add.cpp as a complete program because you’re trying to build an executable (-o add_program).
	Every executable in C++ requires a main() function as the entry point.
	add.cpp does not have a main() function. The linker fails because it can’t find main().

Key Points:
1) Compiling vs. Linking
	When you compile a .cpp file without -c, the compiler implicitly tries to link it into an executable.
	If the file has no main(), linking fails

2) If you compile add.cpp as an object file (using -c), it works:
	>> g++ -c add.cpp -o add.o  # Creates add.o (no linking)
	This creates add.o, which contains the compiled code for the add() function.
	But add.o is not an executable—it’s a piece of code waiting to be linked with other code (like main.cpp).

-------------------------------------------------------------------------------------------------

Why You Can’t Compile add.cpp Individually:
	If you try to compile add.cpp as an executable, it lacks main().
	If you compile it as an object file, it works, but you still need to link it with main.o to create the final 
	program.

IMPORTANT --> Compiling with -c creates object files (partial code), 
              while omitting -c tries to build an executable (which requires main()).

################################################################################################
Key Difference: Object Files vs. Executables
__________________________________________________________________________________________________________________________
Action				  | Command			 |Result                                                  |
__________________________________|______________________________|________________________________________________________|
Create object file (no linking)	  |g++ -c add.cpp -o add.o	 |add.o (contains compiled add() code, no main() required)|
__________________________________|______________________________|________________________________________________________|
Create executable (force link)	  |g++ add.cpp -o add_program    |Fails because add.cpp lacks main()                      |
__________________________________________________________________________________________________________________________|
###############################################################################################
_________________________________________________________________________________________________
What Are Object Files?
An object file (.o or .obj) is a compiled but unlinked binary file containing machine code, data, and metadata. 
It’s a "piece" of a program, not a complete executable.
Generated by: Compiler (e.g., g++ -c file.cpp).
Purpose: To hold compiled code for later linking.
Key Features:
	Contains symbols (function/variable names and addresses).
	Includes relocation information (directions for the linker to fix addresses).
	No entry point (main() is not required).
Structure of an Object File
	Most object files (e.g., ELF on Linux, COFF on Windows) have these sections:
	.text: Machine code for functions (e.g., add() in add.o).
	.data: Initialized global/static variables.
	.bss: Uninitialized global/static variables (space reserved but not stored).
	Symbol Table: List of defined and referenced symbols (e.g., add is defined, main is referenced).
	Relocation Records: Instructions for the linker to adjust addresses when linking.

What Are Executables?
An executable (e.g., program.exe, a.out) is a complete, runnable program created by linking one or more object files.
Generated by: Linker (e.g., g++ main.o add.o -o program).
Purpose: To be loaded into memory and executed by the OS.
Key Features:
	Has an entry point (usually main() in C++).
	Contains resolved symbols (no missing references).
	Includes OS-specific headers (e.g., ELF headers on Linux).
Structure of an Executable
	Header: Metadata (e.g., target OS, entry point address).
	.text: Machine code for all linked functions.
	.data/.bss: Global/static variables.
	Dynamic Linking Info: References to shared libraries (e.g., libstdc++.so).